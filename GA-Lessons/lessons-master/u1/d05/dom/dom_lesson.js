// ============================================================
// INTRODUCTION TO THE DOM
// ============================================================

// ============================================================
// Preliminary Functions

// These are just functions I'm writing to give some structure to our
// exploration of the DOM. We don't need to understand how they work
// to get started.

// To make it more clear that these aren't special functions or built
// into Javascript or anything, I'm putting "tsg" in their
// names. "tsg" stands for Timothy Starbuck Gardner, my full name.

// This is a function that inserts a horizontal line into the page,
// followed by the label we pass it as an argument with a
// cream-colored background.
function tsgSeparator(label){
  var separatorElement = document.createElement("div");
  var upper = document.getElementById("upper");
  separatorElement.setAttribute("class", "separator remark");
  separatorElement.innerText = label;
  upper.appendChild(separatorElement);
}

// This function inserts a cream-colored section with some text in it.
// It's a bit fancy, but we'll be able to explain how it works later
// in the course.
function tsgRemark(){
  var args = Array.prototype.slice.call(arguments);
  var remarkElement = document.createElement("div");
  var upper = document.getElementById("upper");
  upper.appendChild(remarkElement);
  remarkElement.setAttribute("class", "remark remark_text");

  args.forEach(function(remark){
    var remarkBody = document.createElement("p");
    remarkBody.innerText = remark;
    remarkElement.appendChild(remarkBody);
  });

}

// ============================================================
tsgSeparator("Preliminary");

tsgRemark(
  "Follow along in the code!",
  
  "Cream-colored areas such as this one are comments and notes, generated by the functions tsgSeparator and tsgRemark. Everything else is the worked examples for today's lesson.",
  
  "As we proceed with the lesson, uncomment lines of code in the provided script."
);

// // ============================================================
// tsgSeparator("The DOM");

// tsgRemark(
//   "The DOM (Document Object Model) is a representation of a webpage that we can manipulate from Javascript. It is the fundamental interface between Javascript and the visible webpage.",

//   "Every change in the webpage is immediately reflected in the DOM, and every change in the DOM is immediately reflected in the webpage.",

//   "We can see the structure changing both in the browser's viewport, and in the Elements tab of the debugger."
// );

// // ============================================================
// tsgSeparator("Getting Elements By ID");

// tsgRemark(
//   "Let's get the first element in the document body by id, and bind it to a var. We could call it anything, but let's call it upper, because it's going to be the upper element we deal with; \"upper\" is also its id attribute in the HTML.",
  
//   "document.getElementById is a method that takes a string argument and searches through the DOM for an element with a matching id attribute. It returns that element.",

//   "Notice that document.getElementById returns exactly ONE element -- not a collection of elements. Even if we have more than one element in the DOM with the same id attribute, document.getElementById will only return one of them.",

//   "This is one reason why is very important to be sure that no more than one element has a given id attribute at a time on a single page.",

//   "Check the console for the element we've selected."
// );

// var upper = document.getElementById("upper");

// console.log("upper:");
// console.log(upper);

// // ============================================================
// tsgSeparator(
//   "Creating Elements And Adding Them To The DOM"
// );

// // Create a new element. The argument to document.createElement is the
// // tag we would like the new element to have, in this case
// // "div". Notice we haven't added it to the DOM tree yet, so we can't
// // see it.
// var div1 = document.createElement("div");
// // 

// // Set text of firstDiv:
// div1.innerText = "This is div1!";

// // Now we add it to the DOM tree:
// upper.appendChild(div1);

// // If we would like to change an attribute of an element, we can do so using 

// // Let's do that again with another div.

// var div2 = document.createElement("div");
// div2.innerText = "This is div2!";
// upper.appendChild(div2);

// // We can set the attributes of an element using the setAttribute
// // method. We can do this before or after we add the element to the
// // DOM.

// div1.setAttribute("class", "announcement");

// // We can retrieve attributes from elements using getAttribute:

// console.log("the class attribute of div1 is: " + div1.getAttribute("class"));

// tsgRemark(
//   "We can use the same technique to nest created divs."
// );

// var div3 = document.createElement("div");
// div3.innerText = "This is div3!";
// upper.appendChild(div3);

// var div4 = document.createElement("div");
// div4.innerText = "This is div4!";
// // NOTICE! We're calling the appendChild method of div3, _not_ upper:
// div3.appendChild(div4);

// // Exercise: set the class attribute of div4 to "announcement".

// // ==================================================
// tsgSeparator("Removing elements");

// tsgRemark(
//   "Just as we can add elements as children using appendChild, we can remove elements using removeChild."
// );

// // Let's set up some nested elements, just like in the last section:

// var div5 = document.createElement("div");
// div5.innerText = "This is div5!";
// upper.appendChild(div5);

// var div6 = document.createElement("div");
// div6.innerText = "This is div6!";
// div5.appendChild(div6);

// // div6 is now a child element of div5. Let's remove div6:
// div5.removeChild(div6);

// // notice that div6 still _exists_ in memory, it just isn't attached
// // to the DOM tree anymore:

// console.log("div6 still exists:");
// console.log(div6);

// // after removing an element, we can attach it again:

// div5.appendChild(div6);

// // ==================================================
// tsgSeparator("Reparenting (ie, Moving) Elements");

// tsgRemark(
//   "In addition to removing elements from the DOM, we can move them around within the dom."
// );

// // Lets start by making a slightly more complicated nested structure in the DOM.

// var div7 = document.createElement("div");
// div7.innerText = "This is div7!";
// upper.appendChild(div7);

// var div8 = document.createElement("div");
// div8.innerText = "This is div8!";
// div7.appendChild(div8);

// var div9 = document.createElement("div");
// div9.innerText = "This is div9!";
// div7.appendChild(div9);

// // div7 now has two children, div8 and div9.
// // We can move div9 into div8 like so:

// div8.appendChild(div9);

// // Notice that div9 is no longer a child of div7!

// // ==================================================
// tsgSeparator(
//   "Setting styles programmatically"
// );

// tsgRemark(
//   "We've seen how to set the class of an element using setAttribute.",
//   "DOM elements can have many different attributes, just like in normal HTML. Some attributes, such as class, have a special built-in meaning that may affect how they render and behave.",
//   "We can use attributes that don't have some special meaning to store arbitrary information in the DOM. This capability can be very useful in some situations, but it's best not to rely too much on it. The DOM can be an unstable and complicated place, with elements moving around and being deleted, and it's usually better to store important data in a Javascript array or object.",
//   "One important special attribute is style. We can use this to programmatically set the style of a given element. We use the same syntax as CSS."
// );

// // As usual, we start by making a div:

// var div10 = document.createElement("div");
// div10.innerText = "This is div10!";
// upper.appendChild(div10);

// // Let's make div10 red without touching our stylesheet:

// div10.setAttribute("style", "background-color: red;");

// // How about light blue with a red border:

// div10.setAttribute(
//   "style",
//   "background-color: lightblue; border: 5px solid red;"
// );

// // It's a little twitchy, but we can combine getAttribute and
// // setAttribute to add styles to an element:

// var previousDiv10Style = div10.getAttribute("style");
// console.log("previousDiv10Style: " + previousDiv10Style);

// var nextDiv10Style = previousDiv10Style + "background-color: black; color: white;";
// console.log("nextDiv10Style: " + nextDiv10Style);

// div10.setAttribute(
//   "style",
//   nextDiv10Style
// );

// tsgRemark(
//   "Setting styles programmatically like this is a bit controversial, and involves some trade-offs.",
//   "By circumventing the CSS stylesheet, we reduce our ability to control the look of the page by editing that stylesheet, tangling it up with programmatic logic.",
//   "If a designer is focusing on the CSS, they will probably be frustrated if their efforts are thwarted by the front-end programmer's Javascript.",
//   "On the other hand, it can be cumbersome to try to express every nuance of style through pure CSS, especially in an interactive application, and setting the style programmatically gives the programmer absolute control over the look of a given element that no stylesheet can override.",
//   "In general, use stylesheets when you can, and set the style of elements programmatically when you have to."
// );

